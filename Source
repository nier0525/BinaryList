#include <iostream>
#include <stdlib.h>
using namespace std;

// 이분탐색 리스트
// ----------------------
// 삽입과 삭제가 vector, 배열보다 퍼포먼스가 좋은 리스트지만 검색을 위해선 리스트 전체를 순회하는 것은 피할 수 없다.
// 검색이 빈번하게 일어나는 상황에선 성능이 그렇게 좋진 못하다.
// 이러한 문제점을 해소할 수 있는가에 대해 호기심이 생겨 이분탐색과 유사한 기능을 가진 리스트를 구현해보았다.
// 조건을 아래와 같다.
//
// 1. 리스트는 항상 정렬이 되어 있어야 한다.
// 2. 일단 중복값은 제한하였다. ( 제한하지 않아도 문제가 되지는 않는다. )
// 3. 삽입과 삭제가 일어날 때 리스트는 정렬 작업을 진행한다.
// 4. 정렬된 리스트를 가지고 검색 시 이분탐색을 통해 좀 더 빠르게 검색한다.
//
// 이분탐색이라고 하지만 온전한 이분탐색이 아닌 최대한 유사하게 구현해 놓은 것이다.
// 시간복잡도로 따지자면 O(logn) 이라고 생각한다. ( 최선의 경우는 O(N) )
// 
// 1~100 까지 정렬된 데이터를 저장하고 있는 리스트가 있는 경우
// 각 이분탐색을 위한 포인터 변수의 위치는 25, 50, 75 의 값을 가진 노드의 위치로 설정된다.
// 74 라는 값을 찾는다면 50 값을 가진 노드 -> 75 값을 가진 노드 내에서 찾게 된다.
// 결과적으로 일반적인 리스트에선 74번을 순회해야 하는 상황을 24번으로 줄이게 되었다.
//
// 삽입과 삭제가 일어날 때마다 정렬 작업을 하기 때문에 정렬 작업을 할 때도 위의 포인터 변수 위치를 응용하여
// 검색과 동등한 속도로 줄이는 데 성공했다.
// 노드를 바꿀 땐 리스트는 바꾸고자 하는 노드와 패스만 바꾸어주면 되기 때문에 배열에 비해 아주 간단하게 작업이 이루어 진다.
//
// 하지만 이진트리와 성능을 비교하면 삽입,삭제에 대해선 그렇게 뛰어나다고 확신은 못하겠다..
// 애초에 정렬 작업이 있다는 것은 데이터의 양이 많을수록 부담이 커질 수 밖에 없다.
// 이 문제는 해쉬 테이블을 사용하면 쉽게 해결할 수 있을지도 모르겠다.

class Node
{
public:
	int value;
	
	Node* left;
	Node* right;

	Node() = default;
	~Node() = default;
};

class BinaryList
{
private:	
	Node* m_front;	// 맨 앞 위치
	Node* m_end;	// 맨 뒤 위치

	// 이분탐색을 위한 포인터 변수
	Node* m_sub_left_middle;	// m_front - m_middle 사이의 주소
	Node* m_middle;				// m_sub_left_middle - m_sub_right_middle 사이의 주소
	Node* m_sub_right_middle;	// m_middle - m_end 사이의 주소

	size_t m_size;	// 현재 리스트 크기

private:	
	// 리스트에 생성되어 있는 노드들 메모리 해제 작업
	void Nodes_Remove()
	{
		Node* node = m_front;
		while (nullptr != node)
		{
			Node* temp_node = node->right;
			delete node;
			node = temp_node;
		}
		m_size = 0;
	}

	// 리스트 노드 정보 초기화
	void Nodes_Setting()
	{
		m_front = new Node();
		m_end = new Node();

		m_front->right = m_end;
		m_end->left = m_front;

		m_middle = m_front;
		m_sub_left_middle = m_front;
		m_sub_right_middle = m_end;
	}

	// 이분탐색을 위한 포인터 주소 위치 설정
	void MiddlePosition_Setting()
	{
		Node* middle = m_sub_right_middle;
		for (int i = 0; i < ceil(m_size * 0.25); i++)
			if (nullptr != middle)
				middle = middle->left;
		m_middle = middle;

		Node* left = m_middle;
		Node* right = m_middle;

		for (int i = 0; i < round(m_size * 0.25); i++)
		{
			if (nullptr != right)
				right = right->right;

			if (nullptr != left)
				left = left->left;
		}

		m_sub_right_middle = right;
		m_sub_left_middle = left;
	}

	// 이분탐색을 위한 리스트 정렬
	void Sort(Node* _data)
	{
		Node* node = nullptr;
		Node* end = nullptr;

		if (_data->value < m_sub_left_middle->value)
		{
			node = m_front->right;
			end = m_sub_left_middle;
		}
		else if (_data->value < m_middle->value)
		{
			node = m_sub_left_middle;
			end = m_middle;
		}
		else if (_data->value < m_sub_right_middle->value)
		{
			node = m_middle;
			end = m_sub_right_middle;
		}
		else
		{
			node = m_sub_right_middle;
		}

		while (end != node)
		{
			if (_data->value < node->value)
				break;
			node = node->right;
		}
		if (node != nullptr)
		{
			_data->left->right = nullptr;
			m_end->left = _data->left;

			_data->left = node->left;
			_data->right = node;
			
			node->left->right = _data;
			node->left = _data;
		}
	}

public:
	// 생성자
	// 생성 전에 리스트 사이즈를 초기화하고 생성 후에 노드 정보를 설정한다.
	BinaryList() : m_size(0) { Nodes_Setting(); }
	// 소멸자
	// 리스트 내 모든 노드에 대한 삭제를 진행한다.
	~BinaryList() { Nodes_Remove(); }	

public:
	// 리스트 초기화
	void Reset()
	{
		Nodes_Remove();
		Nodes_Setting();
	}
	// 리스트가 비어있는가 여부 확인
	bool Empty() { return m_size == 0 ? true : false; }
	// 리스트 사이즈 읽기
	size_t GetSize() { return m_size; }

	// 리스트 내에 저장된 데이터 찾기
	Node* Search(const int _value) 
	{
		Node* node = nullptr;
		Node* end = nullptr;
		int count = 1;

		if (m_middle != m_front)
		{
			if (_value == m_sub_left_middle->value)
			{
				cout << "[Search] Value : " << _value << " , " << "Count : " << count << endl;
				return m_sub_left_middle;
			}
			else if (_value == m_middle->value)
			{
				cout << "[Search] Value : " << _value << " , " << "Count : " << count << endl;
				return m_middle;
			}
			else if (_value == m_sub_right_middle->value)
			{
				cout << "[Search] Value : " << _value << " , " << "Count : " << count << endl;
				return m_sub_right_middle;
			}
			else if (_value == m_end->left->value)
			{
				cout << "[Search] Value : " << _value << " , " << "Count : " << count << endl;
				return m_end->left;
			}
			else
			{
				if (_value < m_sub_left_middle->value)
				{
					node = m_front->right;
					end = m_sub_left_middle;
				}
				else if (_value < m_middle->value)
				{
					node = m_sub_left_middle->right;
					end = m_middle;
				}
				else if (_value < m_sub_right_middle->value)
				{
					node = m_middle->right;
					end = m_sub_right_middle;
				}
				else if (_value < m_end->left->value)
				{
					node = m_sub_right_middle->right;
					end = m_end->left;
				}
				else
				{
					return nullptr;
				}
			}
		}
		else
			return nullptr;

		while (end != node)
		{
			if (node->value == _value)
				break;
			node = node->right;
			count++;
		}
		if (node == end) return nullptr;

		cout << "[Search] Value : " << _value << " , " << "Count : " << count << endl;
		return node;
	}

	// 리스트 내에 저장 할 데이터 삽입
	bool Insert(const int _value)
	{
		if (nullptr != Search(_value))
		{
			cout << "[Insert Error] " << _value << " is Exists Value" << endl << endl;
			return false;
		}

		Node* node = new Node();
		node->value = _value;		
		node->left = m_end->left;

		m_end->left->right = node;			
		m_end->left = node;		

		m_size++;

		Sort(node);
		MiddlePosition_Setting();
		return true;
	}

	// 리스트 내에 저장된 데이터 삭제
	bool Delete(const int _value)
	{
		Node* node = Search(_value);
		if (nullptr == node) return false;
		m_size--;

		node->left->right = node->right;
		if (nullptr != node->right)
			node->right->left = node->left;
		delete node;

		MiddlePosition_Setting();
		return true;
	}

	// 리스트 내에 저장된 데이터 출력
	void Print()
	{
		if (Empty())
		{
			cout << "List Empty" << endl << endl;
			return;
		}

		Node* node = m_front->right;

		while (nullptr != node)
		{
			cout << node->value << " ";
			node = node->right;
		}		
		cout << endl << endl;

		cout << "Middle : " << m_middle->value << endl;
		cout << "Sub Left Middle : " << m_sub_left_middle->value << endl;
		cout << "Sub Right Middle : " << m_sub_right_middle->value << endl << endl;
	}
};

int main()
{	
	BinaryList list;
	list.Print();

	for (int i = 100; i >= 1; i--)
		list.Insert(i);
	list.Insert(24);
	list.Print();
	
	Node* node = list.Search(14);
	nullptr == node ? cout << "데이터 없음" << endl : cout << "값 : " << node->value << endl;

	node = list.Search(75);
	nullptr == node ? cout << "데이터 없음" << endl : cout << "값 : " << node->value << endl;

	cout << endl;

	return 0;
}
